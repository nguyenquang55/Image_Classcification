# -*- coding: utf-8 -*-
"""model_class_cifar10.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M7tgXAAN_4loMAyCfrcWXyFe_1A9O5mz
"""

!pip install tensorflow
!pip install matplotlib

import numpy as np
import matplotlib.pyplot as plt
import pandas as pd
import seaborn as sns
import keras
import tensorflow.keras

(X_train, y_train), (X_test, y_test) = keras.datasets.cifar10.load_data()

X_train.shape,y_train.shape

X_test.shape,y_test.shape

class_labels = [
    "Airplane",  # 0
    "Automobile",  # 1
    "Bird",  # 2
    "Cat",  # 3
    "Deer",  # 4
    "Dog",  # 5
    "Frog",  # 6
    "Horse",  # 7
    "Ship",  # 8
    "Truck"  # 9
]

X_train=X_train.astype('float32') / 255.0
X_test=X_test.astype('float32') / 255.0

from sklearn.model_selection import train_test_split
X_train,X_val,y_train,y_val=train_test_split(X_train,y_train,test_size=0.2,random_state=42)

num_classes = 10

from tensorflow.keras.utils import to_categorical
y_train = to_categorical(y_train, num_classes=num_classes)
y_test = to_categorical(y_test, num_classes=num_classes)
print(y_train.shape)
print(y_test.shape)

print(y_train)

X_train.shape,y_train.shape

X_val.shape,y_val.shape

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout, Activation, BatchNormalization
import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.regularizers import l2

model = Sequential([
    Conv2D(32, (3, 3), padding='same', activation='relu', input_shape=(X_train.shape[1:])),
    BatchNormalization(),
    Conv2D(32, (3, 3), padding='same', activation='relu'),
    BatchNormalization(),
    MaxPooling2D(pool_size=(2, 2)),
    Dropout(0.25),

    Conv2D(64, (3, 3), padding='same', activation='relu'),
    BatchNormalization(),
    Conv2D(64, (3, 3), padding='same', activation='relu'),
    BatchNormalization(),
    MaxPooling2D(pool_size=(2, 2)),
    Dropout(0.25),

    Conv2D(128, (3, 3), padding='same', activation='relu'),
    BatchNormalization(),
    Conv2D(128, (3, 3), padding='same', activation='relu'),
    BatchNormalization(),
    MaxPooling2D(pool_size=(2, 2)),
    Dropout(0.3),

    Flatten(),
    Dense(256, activation='relu'),
    Dropout(0.5),
    Dense(10, activation='softmax')
])
model.summary()

print(X_train.shape)
print(y_train.shape)

from tensorflow.keras.preprocessing.image import ImageDataGenerator
train_datagen = ImageDataGenerator(
    rescale=1.0/255,
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True
)

test_datagen = ImageDataGenerator(rescale=1.0/255)

train_generator = train_datagen.flow(
    X_train,
    y_train,
    batch_size=64
)

test_generator = test_datagen.flow(
    X_test,
    y_test,
    batch_size=64
)

model.compile(optimizer='adam',
              loss='categorical_crossentropy',
              metrics=['accuracy'])

from tensorflow.keras.callbacks import ReduceLROnPlateau
from tensorflow.keras.callbacks import EarlyStopping
history = model.fit(
    train_generator,
    validation_data=test_generator,
    epochs=25,
)

history =model.fit(X_train,y_train,
                   epochs=10,
                   batch_size=64,
                   verbose=1,
                   validation_data=(X_test,y_test))

model.save('model_cifar10.h5')

predictions = model.predict(X_val[:50])
predicted_classes = predictions.argmax(axis=1)

for i in range(50):
  print(f"Sample {i}:")
  print(f"  Predicted class label: {predicted_classes[i]}, Class name: {class_labels[predicted_classes[i]]}")
  print(f"  True class label: {y_test[i][0]}, Class name: {class_labels[y_test[i][0]]}")

model.save('model_cifar10.h5')

# Load your image (adjust the path to your image)
new_image = load_img('/content/giay-the-thao-nam-7583-8_291105232abf41008a3452013257376f.webp', target_size=(28, 28), color_mode='grayscale')

# Convert the image to a numpy array and normalize
new_image_array = img_to_array(new_image) / 255.0

# Add batch dimension (1, 28, 28, 1)
new_image_array = np.expand_dims(new_image_array, axis=0)

# Make a prediction for the new image
y_pred_new = model.predict(new_image_array)

# Get the predicted class
y_pred_class = y_pred_new.argmax(axis=1)

# Print predicted class label for the new image
print(f"Predicted label for the new image: {class_labels[y_pred_class[0]]}")

!pip install tf2onnx

model.save('model.h5')

import torch

# Assuming you have a PyTorch model
torch.save(model.state_dict(), 'model.pt')